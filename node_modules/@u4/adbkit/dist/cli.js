"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const commander_1 = require("commander");
const node_forge_1 = __importDefault(require("node-forge"));
const adb_1 = require("./adb");
const auth_1 = __importDefault(require("./adb/auth"));
const packetreader_1 = __importDefault(require("./adb/tcpusb/packetreader"));
const path_1 = __importDefault(require("path"));
const utils_1 = __importDefault(require("./adb/utils"));
const cli_common_1 = require("./cli-common");
require("./cli-airplane");
require("./cli-connectivity");
require("./cli-tethering");
require("./cli-boatware");
const pkg = JSON.parse(fs_1.default.readFileSync(path_1.default.join(__dirname, '..', 'package.json'), { encoding: 'utf-8' }));
commander_1.program.version(pkg.version);
commander_1.program
    .command('pubkey-convert <file>')
    .option('-f, --format <format>', 'format (pem or openssh)', String, 'pem')
    .description('Converts an ADB-generated public key into PEM format.')
    .action(async (file, options) => {
    const key = await auth_1.default.parsePublicKey(fs_1.default.readFileSync(file).toString('utf8'));
    switch (options.format.toLowerCase()) {
        case 'pem':
            return console.log(node_forge_1.default.pki.publicKeyToPem(key).trim());
        case 'openssh':
            return console.log(node_forge_1.default.ssh.publicKeyToOpenSSH(key, 'adbkey').trim());
        default:
            console.error("Unsupported format '" + options.format + "'");
            return process.exit(1);
    }
});
commander_1.program
    .command('pubkey-fingerprint <file>')
    .description('Outputs the fingerprint of an ADB-generated public key.')
    .action(async (file) => {
    const key = await auth_1.default.parsePublicKey(fs_1.default.readFileSync(file).toString('utf8'));
    return console.log('%s %s', key.fingerprint, key.comment);
});
commander_1.program
    .command('usb-device-to-tcp <serial>')
    .option('-p, --port <port>', 'port number', (value) => String(value), '6174')
    .description('Provides an USB device over TCP using a translating proxy.')
    .action((serial, options) => {
    const adb = (0, adb_1.createClient)();
    const server = adb
        .createTcpUsbBridge(serial, {
        auth: () => Promise.resolve(),
    })
        .on('listening', () => console.info('Connect with `adb connect localhost:%d`', options.port))
        .on('error', (err) => console.error('An error occured: ' + err.message));
    server.listen(options.port);
});
commander_1.program
    .command('parse-tcp-packets <file>')
    .description('Parses ADB TCP packets from the given file.')
    .action((file) => {
    const reader = new packetreader_1.default(fs_1.default.createReadStream(file));
    reader.on('packet', (packet) => console.log(packet.toString()));
});
commander_1.program
    .command('capture dest [serials...]')
    .description('capture screen of one or many device as png.')
    .action(async (dest, serials) => {
    const devices = await (0, cli_common_1.getClientDevice)(serials);
    for (let i = 0; i < devices.length; i++) {
        const device = devices[i];
        let out = dest;
        if (devices.length > 1) {
            out = path_1.default.join(path_1.default.dirname(out), device.serial + '-' + path_1.default.basename(out));
        }
        const stream = await device.screencap();
        const capture = await utils_1.default.readAll(stream);
        fs_1.default.writeFileSync(dest, capture);
    }
});
commander_1.program.parse(process.argv);
//# sourceMappingURL=cli.js.map