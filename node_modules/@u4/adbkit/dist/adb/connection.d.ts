/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import EventEmitter from 'events';
import Parser from './parser';
import { Socket } from 'net';
import { ClientOptions } from '../models/ClientOptions';
import { Client } from '..';
/**
 * enforce EventEmitter typing
 */
interface IEmissions {
    connect: () => void;
    end: () => void;
    drain: () => void;
    timeout: () => void;
    close: (hadError: boolean) => void;
    error: (error: Error) => void;
}
export default class Connection extends EventEmitter {
    private _parent;
    socket: Socket;
    parser: Parser;
    private triedStarting;
    options: ClientOptions;
    private _errored?;
    constructor(_parent: Client);
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    get parent(): Client;
    connect(): Promise<Connection>;
    /**
     * added for Mock testing
     */
    getSocket(): unknown;
    end(): this;
    /**
     * New Writen Call imported from Piotr Roszatycki implementation
     * https://github.com/dex4er/js-promise-writable
     * this method take care of any drain needed.
     *
     * @param data data to write
     * @returns number of byte writen
     */
    write(data: Buffer): Promise<number>;
    startServer(): Promise<{
        stdout: string;
        stderr: string;
    }>;
    private _exec;
}
export {};
//# sourceMappingURL=connection.d.ts.map